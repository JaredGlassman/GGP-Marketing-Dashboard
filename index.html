<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Good Guys Pools Performance Dashboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!-- External libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js" defer></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js" defer></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/luxon/3.4.4/luxon.min.js" defer></script>
<style>
  :root {
    --bg:#e6f7fb; --card:#ffffff; --muted:#4b5563; --ink:#0f172a;
    --accent:#0ea5e9; --accent2:#22d3ee; --ok:#16a34a; --okbg:#e7f7ed;
  }
  body { margin:0; background:var(--bg); font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color:var(--ink);}
  .wrap{max-width:1220px; margin:0 auto; padding:20px;}
  .header{
    position:relative; border-radius:18px; padding:28px 20px 36px; overflow:hidden; color:#fff;
    background:linear-gradient(180deg, rgba(14,165,233,.85), rgba(34,211,238,.85));
  }
  .header::before{
    content:""; position:absolute; inset:0;
    background-image:url('af4092da-8a7b-45ac-8c5d-3855ea11f685.png');
    background-size:cover; background-position:center; opacity:.25;
  }
  .header > * { position:relative; }
  .header h1{margin:0 0 8px; font-size:28px; letter-spacing:.2px}
  .uploads{display:grid; grid-template-columns:repeat(3,1fr); gap:16px; margin:18px 0}
  .u{position:relative; background:var(--card); border:2px dashed #cbd5e1; border-radius:12px; padding:16px; text-align:center; transition:all .2s ease}
  .u.ok{ border-color: var(--ok); background: var(--okbg); }
  .u input{display:none}
  .u label{display:block; cursor:pointer; font-weight:700; margin-bottom:6px}
  .u .hint{color:#64748b; font-size:12px}
  .tick{position:absolute; top:8px; right:10px; font-size:18px; color:var(--ok); display:none}
  .u.ok .tick{display:block}
  .bar{display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin:14px 0}
  select{padding:10px 12px; border-radius:10px; border:1px solid #d1d5db; background:#fff}
  .btn{display:inline-block; padding:14px 24px; background:var(--accent); color:#fff; border:none; border-radius:12px; cursor:pointer; font-weight:800}
  .oknote{background:var(--okbg); border:1px solid #a7e7bf; color:#065f46; padding:10px 12px; border-radius:10px; margin-top:10px; display:none}
  .err{background:#fee2e2; border:1px solid #fecaca; color:#991b1b; padding:10px 12px; border-radius:10px; margin-top:10px; display:none}
  .grid{display:grid; grid-template-columns:repeat(3,1fr); gap:14px}
  .card{background:var(--card); border-radius:14px; padding:18px; box-shadow:0 1px 2px rgba(0,0,0,.06)}
  .big{font-size:28px; font-weight:800}
  .muted{color:#64748b; text-transform:uppercase; letter-spacing:.05em; font-size:12px}
  .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center}
  .charts{display:grid; grid-template-columns:1fr; gap:16px; margin:18px 0}
  canvas{background:#fff; border-radius:12px; padding:10px}
  .table{overflow:auto; background:#fff; border-radius:12px; padding:10px}
  table{width:100%; border-collapse:collapse}
  th,td{padding:10px; border-bottom:1px solid #e5e7eb; text-align:left}
  th{font-size:12px; text-transform:uppercase; color:#64748b}
  .month-checkboxes { display:flex; flex-wrap:wrap; gap:8px; max-width:100%; }

  /* Layout for each filter row.  We use flexbox with no wrapping to ensure all
     checkboxes appear on a single line for each filter.  Horizontal scroll
     will appear if there are too many items to fit in the available space. */
  .filter-row{
    display:flex;
    align-items:center;
    flex-wrap:nowrap;
    gap:8px;
    margin-bottom:8px;
    overflow-x:auto;
    padding-bottom:4px;
  }

  /* Specific styling for the campaign checkboxes container.  Ensures that
     campaign options appear inline with consistent spacing. */
  .campaign-checkboxes label{
    display:inline-flex;
    align-items:center;
    margin-right:8px;
  }

  /* Percentage change indicator styles.  These classes control the color and sizing of
     percentage differences displayed next to metric values.  Positive changes are green,
     negative changes are red, and neutral changes are grey. */
  .diff-positive { color:#16a34a; font-size:0.85rem; margin-left:4px; }
  .diff-negative { color:#dc2626; font-size:0.85rem; margin-left:4px; }
  .diff-neutral { color:#6b7280; font-size:0.85rem; margin-left:4px; }
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <h1>üèä‚Äç‚ôÇÔ∏è Good Guys Pools Performance Dashboard</h1>
    <p>Track contacts from creation to close and map platform spend</p>
  </div>

  <div class="uploads">
    <div class="u" id="u-contacts"><span class="tick">‚úì</span><label for="contactsCsv">Upload Contacts CSV</label><input id="contactsCsv" type="file" accept=".csv"/><div class="hint">HubSpot contacts export</div></div>
    <div class="u" id="u-deals"><span class="tick">‚úì</span><label for="dealsCsv">Upload Deals CSV</label><input id="dealsCsv" type="file" accept=".csv"/><div class="hint">HubSpot deals export</div></div>
    <div class="u" id="u-meta"><span class="tick">‚úì</span><label for="metaCsv">Upload Meta Spend CSV</label><input id="metaCsv" type="file" accept=".csv"/><div class="hint">Meta spend</div></div>
    <div class="u" id="u-google"><span class="tick">‚úì</span><label for="googleCsv">Upload Google Ads Spend CSV</label><input id="googleCsv" type="file" accept=".csv"/><div class="hint">Google Ads (Day + Billed cost)</div></div>
    <div class="u" id="u-bing"><span class="tick">‚úì</span><label for="bingCsv">Upload Bing Spend CSV</label><input id="bingCsv" type="file" accept=".csv"/><div class="hint">Bing Ads (Date + Spend)</div></div>
    <div class="u" id="u-thumb"><span class="tick">‚úì</span><label for="thumbtackCsv">Upload Thumbtack Spend CSV</label><input id="thumbtackCsv" type="file" accept=".csv"/><div class="hint">Thumbtack (date + amount_usd)</div></div>
  </div>

  <div class="row">
    <button class="btn" id="processBtn">Process Data & Generate Dashboard</button>
    <div id="status" class="oknote">‚úÖ Data loaded</div>
    <div id="error" class="err">‚ùå A parsing error occurred. Open the console for details.</div>
  </div>

  <div class="bar">
    <!-- Primary date range filter row -->
    <div class="filter-row" id="primaryMonthRow">
      <span class="muted">Filter by Month:</span>
      <div id="monthAllTime" class="checkgroup">
        <label style="display:inline-flex;align-items:center;margin-right:8px;">
          <input type="checkbox" id="allTimeCb"/>
          <span style="margin-left:4px;">All time</span>
        </label>
      </div>
      <div id="monthCheckboxes" class="month-checkboxes"></div>
    </div>
    <!-- Comparison date range filter row -->
    <div class="filter-row" id="compareMonthRow">
      <span class="muted">Compare by Month:</span>
      <div id="compareAllTime" class="checkgroup">
        <label style="display:inline-flex;align-items:center;margin-right:8px;">
          <input type="checkbox" id="compareAllTimeCb"/>
          <span style="margin-left:4px;">All time</span>
        </label>
      </div>
      <div id="compareMonthCheckboxes" class="month-checkboxes"></div>
    </div>
    <!-- Channel filter row -->
    <div class="filter-row" id="channelRow">
      <span class="muted">Filter by Channel:</span>
      <div id="channelCheckboxes" class="channel-checkboxes">
        <label style="display:inline-flex;align-items:center;margin-right:8px;">
          <!-- Do not pre-check the All Channels box.  Users may select specific channels
               or leave all boxes unchecked to indicate an aggregated view across all channels. -->
          <input type="checkbox" value="all" />
          <span style="margin-left:4px;">All Channels</span>
        </label>
        <label style="display:inline-flex;align-items:center;margin-right:8px;">
          <input type="checkbox" value="Meta Ads" />
          <span style="margin-left:4px;">Meta Ads</span>
        </label>
        <label style="display:inline-flex;align-items:center;margin-right:8px;">
          <input type="checkbox" value="Google Ads" />
          <span style="margin-left:4px;">Google Ads</span>
        </label>
        <label style="display:inline-flex;align-items:center;margin-right:8px;">
          <input type="checkbox" value="Bing Ads" />
          <span style="margin-left:4px;">Bing Ads</span>
        </label>
        <label style="display:inline-flex;align-items:center;margin-right:8px;">
          <input type="checkbox" value="Thumbtack" />
          <span style="margin-left:4px;">Thumbtack</span>
        </label>
        <label style="display:inline-flex;align-items:center;margin-right:8px;">
          <input type="checkbox" value="Angi" />
          <span style="margin-left:4px;">Angi</span>
        </label>
        <label style="display:inline-flex;align-items:center;margin-right:8px;">
          <input type="checkbox" value="Boostmaps" />
          <span style="margin-left:4px;">Boostmaps</span>
        </label>
        <label style="display:inline-flex;align-items:center;margin-right:8px;">
          <input type="checkbox" value="Direct" />
          <span style="margin-left:4px;">Direct</span>
        </label>
        <label style="display:inline-flex;align-items:center;margin-right:8px;">
          <input type="checkbox" value="Referral" />
          <span style="margin-left:4px;">Referral</span>
        </label>
      </div>
    </div>
    <!-- Meta campaign filter row: initially hidden, becomes visible when Meta Ads channel is selected -->
    <div class="filter-row" id="campaignRow" style="display:none;">
      <span class="muted" id="campaignLabel">FB Campaign:</span>
      <div id="campaignCheckboxes" class="campaign-checkboxes"></div>
    </div>
  </div>

    <div class="grid">
    <!-- Each metric card now explicitly labels the primary and comparison values with (R1|R2) so it's clear
         that the two numbers correspond to the selected date ranges.  The values are updated in the
         render() function. -->
    <div class="card"><div class="big" id="leadsNum">0</div><div class="muted">Leads (R1|R2)</div></div>
    <div class="card"><div class="big" id="svNum">0</div><div class="muted">Site Visits (R1|R2)</div></div>
    <div class="card"><div class="big" id="svConv">0%</div><div class="muted">Site‚ÄëVisit Conversion (R1|R2)</div></div>
    <div class="card"><div class="big" id="dealSize">$0</div><div class="muted">Total Won Deal Size (R1|R2)</div></div>
    <div class="card"><div class="big" id="closedNum">0</div><div class="muted">Closed Deals (R1|R2)</div></div>
    <div class="card"><div class="big" id="wonNum">0</div><div class="muted">Deals Won (R1|R2)</div></div>
    <div class="card"><div class="big" id="spend">$0</div><div class="muted">Total Spend (R1|R2)</div></div>
    <div class="card"><div class="big" id="cpl">$0</div><div class="muted">Avg Cost / Lead (R1|R2)</div></div>
    <div class="card"><div class="big" id="cpsv">$0</div><div class="muted">Avg Cost / Site Visit (R1|R2)</div></div>
    <!-- Additional metrics for comparing ranges and marketing analysis.  Each card displays the primary
         range (R1) value and the comparison range (R2) value separated by a vertical bar. -->
    <div class="card"><div class="big" id="costPerDeal">$0 | $0</div><div class="muted">Cost per Deal Won (R1|R2)</div></div>
    <div class="card"><div class="big" id="avgDealVal">$0 | $0</div><div class="muted">Avg Deal Value (R1|R2)</div></div>
    <div class="card"><div class="big" id="marketingProfit">$0 | $0</div><div class="muted">Marketing Profit (R1|R2)</div></div>
    <div class="card"><div class="big" id="dealConv">0% | 0%</div><div class="muted">Deal Conversion (R1|R2)</div></div>
  </div>

  <!-- Charts -->
  <div class="charts">
    <canvas id="trend1" height="80"></canvas>
    <canvas id="trend2" height="80"></canvas>
    <canvas id="trend3" height="80"></canvas>
    <canvas id="trend4" height="80"></canvas>
    <!-- New charts for additional metrics -->
    <canvas id="trend5" height="80"></canvas>
    <canvas id="trend6" height="80"></canvas>
    <canvas id="trend7" height="80"></canvas>
  </div>

  <div class="table">
    <table id="detailTbl">
      <thead>
        <tr>
          <th>Month</th><th>Channel</th><th>Leads</th><th>Site Visits</th>
          <th>Closed</th><th>Won</th><th>Spend</th><th>CPL</th><th>CPSV</th><th>Total Won Deal Size</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script>
function ready(fn){ if(document.readyState!=='loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
ready(()=>{
  // Channel checkbox mutual exclusivity for "All Channels"
  // Allow the user to deselect all channels.  When "All Channels" is checked,
  // uncheck the individual channel boxes.  When an individual channel box is
  // checked, uncheck "All Channels".  Unlike the previous implementation,
  // we no longer automatically reselect "All Channels" when none are checked.
  document.addEventListener('change', (e)=>{
    if(!(e.target && e.target.closest('#channelCheckboxes'))) return;
    const allCb = document.querySelector('#channelCheckboxes input[value="all"]');
    const others = Array.from(document.querySelectorAll('#channelCheckboxes input:not([value="all"])'));
    if(e.target.value === "all"){
      if(allCb.checked){ others.forEach(cb=>cb.checked=false); }
    } else {
      if(e.target.checked){ allCb.checked=false; }
    }
    // When both allCb and others are unchecked, the selectedChannelsArr will be empty.
    // In render(), an empty selection is treated as aggregated across all channels.
  });
  if(typeof Papa==='undefined' || typeof Chart==='undefined' || typeof luxon==='undefined'){
    document.getElementById('error').style.display='block'; return;
  }

  // Ensure the comparison "All time" checkbox (R2) starts unchecked.  Without this,
  // browsers may retain a checked state from previous sessions or default styling
  // may appear selected.  Explicitly setting it to false on load prevents R2
  // values from showing when no comparison months are selected.
  const compareAllTimeInput = document.getElementById('compareAllTimeCb');
  if(compareAllTimeInput){
    compareAllTimeInput.checked = false;
  }
  [["contactsCsv","u-contacts"],["dealsCsv","u-deals"],["metaCsv","u-meta"],["googleCsv","u-google"],["bingCsv","u-bing"],["thumbtackCsv","u-thumb"]]
    .forEach(([inputId, boxId])=>{
      const input=document.getElementById(inputId), box=document.getElementById(boxId);
      input.addEventListener('change', ()=>{ if(input.files && input.files.length){ box.classList.add('ok'); } else { box.classList.remove('ok'); } });
    });

  const tz='America/New_York';
  const { DateTime } = luxon;
  let contacts=[], deals=[], spend={Meta:[], Google:[], Bing:[], Thumbtack:[]};
  let datasets={}, monthOptions=new Set();
  let metaCampaign={}, metaSpendCampaign={};

  // Smart CSV: strip report headers and keep only rows with the expected columns present
  async function parseCSVSmart(file, hint){
    const raw = await file.text();
    const lines = raw.replace(/\r\n/g, '\n').split('\n');
    let start = 0;
    const finders = {
      // Detect header for Google Ads spend. Must match "Day" column surrounded by commas or start/end of line.
      google: l => ((/(^|,)Day(,|$)/.test(l) && /Billed\s*cost/i.test(l))),
      bing: l => /^("?Account name"?,|Account name,)/.test(l),
      thumb: l => /^date,/.test(l),
      meta: l => /^"?Reporting starts"?,/.test(l),
      generic: l => /,/.test(l)
    };
    const test = hint==='google' ? finders.google
               : hint==='bing' ? finders.bing
               : hint==='thumb' ? finders.thumb
               : hint==='meta' ? finders.meta
               : finders.generic;
    for(let i=0;i<lines.length;i++){ if(test(lines[i])){ start=i; break; } }
    const sliced = lines.slice(start).join('\n');
    return new Promise((res,rej)=>{
      Papa.parse(sliced, {header:true,skipEmptyLines:true,complete:r=>res(r.data),error:rej});
    });
  }

  const norm=s=>(s??'').toString().trim();
  const lc=s=>norm(s).toLowerCase();
  function parseDate(str){
    if(!str) return null;
    // Trim whitespace and filter out purely numeric strings.  HubSpot sometimes uses 0/1 flags in date fields; these
    // should not be interpreted as valid dates.  Only strings containing non-digit characters will proceed to parsing.
    const trimmed = str.toString().trim();
    if(/^[0-9]+$/.test(trimmed)) return null;
    let dt=DateTime.fromISO(str,{zone:tz}); if(dt.isValid) return dt;
    dt=DateTime.fromISO(str.replace(' ','T'),{zone:tz}); if(dt.isValid) return dt;
    const patterns=['yyyy-MM-dd','M/d/yyyy','MM/dd/yyyy','yyyy-MM-dd HH:mm:ss','M/d/yyyy H:mm','M/d/yyyy h:mm a','MMM d, yyyy'];
    for(const p of patterns){ dt=DateTime.fromFormat(str,p,{zone:tz}); if(dt.isValid) return dt; }
    // As a last resort, attempt native Date parsing only if the string includes non-digit characters.
    try{
      if(/[^0-9]/.test(trimmed)){
        const js = new Date(trimmed);
        if(!isNaN(js)) return DateTime.fromJSDate(js,{zone:tz});
      }
    }catch(e){}
    return null;
  }

  // Determine if a string resembles a valid date. HubSpot sometimes stores boolean flags or short
  // numeric strings (e.g., "1" or "0") in date fields; these should not be treated as dates.
  // A string is considered date-like if it has at least six characters and contains common date
  // delimiters (slash, hyphen, space) or a three-letter month name (e.g., Jan, Feb). Otherwise
  // it is likely not a real date and will be ignored.
  function looksLikeDate(str){
    if(!str) return false;
    const t = str.toString().trim();
    if(t.length < 6) return false;
    if(/[A-Za-z]{3}/.test(t) || /[\/-]/.test(t) || /\s/.test(t)){
      return true;
    }
    return false;
  }
  const monthKey=dtStr=>{ const dt=parseDate(dtStr); return dt ? dt.toFormat('yyyy-LL') : null; };
  const addMonthOption=mk=>{ if(mk) monthOptions.add(mk); };

  // Channel mapping prioritizes Manual Lead Source and Lead Source (Custom).
  // This function normalizes the values and uses a case-insensitive includes check to
  // capture variations such as "Angi Lead" or "Thumbtack marketplace".  It falls
  // back to the traffic source drill-down logic if no manual or custom lead source is found.
  function mapChannelFromContact(c){
    // Determine the correct columns for manual and custom lead sources by matching keys
    // case-insensitively. This increases robustness to variations like "manual lead source "
    // or "Lead Source (Custom )". If none found, fall back to known names.
    let manualRaw = '';
    let lscRaw = '';
    for(const key in c){
      const normalized = key.toLowerCase().replace(/\s+/g,'');
      if(!manualRaw && normalized.includes('manualleadsource')) manualRaw = c[key];
      if(!lscRaw && normalized.includes('leadsource(custom)')) lscRaw = c[key];
    }
    if(!manualRaw) manualRaw = c["Manual Lead Source"];
    if(!lscRaw) lscRaw = c["Lead Source (Custom)"];
    // Determine traffic drill-down fields similarly to guard against header variations.
    let d1Raw = '';
    let d2Raw = '';
    for(const key in c){
      const normKey = key.toLowerCase().replace(/\s+/g,'');
      if(!d1Raw && normKey.includes('originaltrafficsourcedrill-down1')) d1Raw = c[key];
      if(!d2Raw && normKey.includes('originaltrafficsourcedrill-down2')) d2Raw = c[key];
    }
    if(!d1Raw) d1Raw = c["Original Traffic Source Drill-Down 1"];
    if(!d2Raw) d2Raw = c["Original Traffic Source Drill-Down 2"];
    const manual = lc(manualRaw);
    const lsc = lc(lscRaw);
    const d1 = lc(d1Raw);
    const d2 = norm(d2Raw);
    // If Manual Lead Source contains referral, thumbtack or angi, assign that channel.
    // Check for referral before other sources to avoid misclassification of mixed strings like "angi referral".
    if(manual && manual.includes('referral')) return { channel:'Referral', fbCampaign:null };
    if(manual && manual.includes('thumbtack')) return { channel:'Thumbtack', fbCampaign:null };
    if(manual && manual.includes('angi')) return { channel:'Angi', fbCampaign:null };
    // Otherwise, look at Lead Source (Custom). Check referral before others.
    if(lsc && lsc.includes('referral')) return { channel:'Referral', fbCampaign:null };
    if(lsc && lsc.includes('thumbtack')) return { channel:'Thumbtack', fbCampaign:null };
    if(lsc && lsc.includes('angi')) return { channel:'Angi', fbCampaign:null };
    // Fall back to traffic source drill-down logic.
    if(d1==='crm_ui') return {channel:'Direct', fbCampaign:null};
    if(d1.includes('construction campaign')||d1.includes('service campaign')||d1.includes('maintenance campaign')||d1.includes('retargeting')||d1.includes('good guys pools website campaign updated campaign')||d1.includes('good guys pools leads - higher quality leads')||d1.includes('good guys pools leads')||d1.includes('120218493912890700')) {
      return {channel:'Meta Ads', fbCampaign: d2 || 'Unspecified'};
    }
    if(d1.includes('facebook')) return {channel:'Meta Ads', fbCampaign: d2 || 'Unspecified'};
    if(d1.includes('good guys pools search')||d1.includes('good guys pools - sales - search')||d1.includes('adwords')||d1.includes('unknown keywords')) return {channel:'Google Ads', fbCampaign:null};
    if(d1.includes('boostmaps')) return {channel:'Boostmaps', fbCampaign:null};
    if(d1.includes('bing')) return {channel:'Bing Ads', fbCampaign:null};
    if(d1.includes('instagram')||d1.includes('ig')||d1.includes('fb')||d1.includes('meta')) return {channel:'Meta Ads', fbCampaign: d2 || 'Unspecified'};
    // If there is some drill-down info but not recognized, treat as direct.
    if(d1) return {channel:'Direct', fbCampaign:null};
    return {channel:'Direct', fbCampaign:null};
  }

  function buildContactIndex(cs){
    const idx={byId:new Map(), byEmail:new Map(), byName:new Map()};
    cs.forEach(c=>{
      const id=norm(c["Record ID"]); if(id) idx.byId.set(id,c);
      const em=lc(c["Email"]); if(em) idx.byEmail.set(em,c);
      // Combine first and last names, trim the full string before lowercasing
      const nm=lc((norm(c["First Name"])+' '+norm(c["Last Name"])).trim()); if(nm) idx.byName.set(nm,c);
    }); return idx;
  }

  function matchDealToContact(deal, idx){
    const id=norm(deal["Contact ID"]); if(id && idx.byId.has(id)) return idx.byId.get(id);
    const em=lc(deal["Contact email"]); if(em && idx.byEmail.has(em)) return idx.byEmail.get(em);
    const nm=lc(deal["Contact name"]); if(nm && idx.byName.has(nm)) return idx.byName.get(nm);
    const ids=norm(deal["Associated Contact IDs"]).split(/[;,]/).map(s=>s.trim()).filter(Boolean);
    for(const i of ids){ if(idx.byId.has(i)) return idx.byId.get(i); }
    const emails=norm(deal["All Associated Contact Emails"]).split(/[;,]/).map(s=>lc(s)).filter(Boolean);
    for(const e of emails){ if(idx.byEmail.has(e)) return idx.byEmail.get(e); }
    const names=norm(deal["All Associated Contact Names"]).split(/[;,]/).map(s=>lc(s)).filter(Boolean);
    for(const n of names){ if(idx.byName.has(n)) return idx.byName.get(n); }
    return null;
  }

  function monthSpendFromRows(rows,type){
    const out={};
    rows.forEach(r=>{
      let mk=null, amt=0;
      if(type==='Meta'){
        mk=monthKey(r['Reporting starts']||r['Date']||r['Start Date']);
        amt=parseFloat((r['Amount spent (USD)']||r['Amount']||r['Spend']||'0').toString().replace(/[^0-9.\-]/g,''))||0;
        const camp=(r['Campaign name']||'Unspecified').toString().trim();
        if(mk){ if(!metaSpendCampaign[mk]) metaSpendCampaign[mk]={}; metaSpendCampaign[mk][camp]=(metaSpendCampaign[mk][camp]||0)+amt; }
      }
      if(type==='Google'){
        mk=monthKey(r['Day']||r['Date']);
        amt=parseFloat((r['Billed cost']||r['Cost']||r['Billed Cost']||'0').toString().replace(/[^0-9.\-]/g,''))||0;
      }
      if(type==='Bing'){
        mk=monthKey(r['Date']);
        amt=parseFloat((r['Spend']||r['Cost']||'0').toString().replace(/[^0-9.\-]/g,''))||0;
      }
      if(type==='Thumbtack'){
        mk=monthKey(r['date']||r['Date']);
        amt=parseFloat((r['amount_usd']||r['Amount']||'0').toString().replace(/[^0-9.\-]/g,''))||0;
      }
      if(mk){ out[mk]=(out[mk]||0)+amt; }
    });
    return out;
  }

  document.getElementById('processBtn').addEventListener('click', async ()=>{
    try{
      const [fC,fD,fM,fG,fB,fT] = ['contactsCsv','dealsCsv','metaCsv','googleCsv','bingCsv','thumbtackCsv'].map(id=>document.getElementById(id).files[0]);
      if(!fC||!fD){ alert('Upload Contacts and Deals CSVs first.'); return; }
      contacts = await parseCSVSmart(fC);
      deals = await parseCSVSmart(fD);
      if(fM) spend.Meta = await parseCSVSmart(fM,'meta');
      if(fG) spend.Google=await parseCSVSmart(fG,'google');
      if(fB) spend.Bing=await parseCSVSmart(fB,'bing');
      if(fT) spend.Thumbtack=await parseCSVSmart(fT,'thumb');

      const idx = buildContactIndex(contacts);
      const contactInfo=new Map();
      const monthSet=new Set();
      metaCampaign={}; metaSpendCampaign={};
      const perContact=new Map();

      contacts.forEach(c=>{
        const id=norm(c['Record ID']); if(!id) return;
        // Determine month key for contact creation. If parsing fails, assign 'Unknown'
        let mk=monthKey(c['Create Date']||c['Created Date']||c['Date Created']||c['Create date']);
        if(!mk) mk = 'Unknown';
        const {channel, fbCampaign} = mapChannelFromContact(c);
        contactInfo.set(id,{channel, fbCampaign, createMonth:mk});
        // Always add month key, including 'Unknown', to month set
        monthSet.add(mk);
        if(channel==='Meta Ads'){
          const camp=(fbCampaign||'Unspecified').toString().trim();
          if(mk){
            if(!metaCampaign[mk]) metaCampaign[mk] = {};
            if(!metaCampaign[mk][camp]) metaCampaign[mk][camp] = {leads:0,sv:0,closed:0,won:0,spend:0,dealSize:0};
            metaCampaign[mk][camp].leads++;
          }
        }
        if(!perContact.has(id)) perContact.set(id,{svMonths:new Set(), closedMonths:new Set(), wonMonths:new Set(), totalWon:0});
        const svDate = norm(c['Date entered "Opportunity (Site Visit) (Lifecycle Stage Pipeline)"']);
        // Only count as a site visit if the field appears to be a legitimate date (has delimiters
        // or month names).  This avoids treating numeric flags like "0" or "1" as dates.
        if(svDate && looksLikeDate(svDate)){
          const svParsed = parseDate(svDate);
          if(svParsed){
            if(mk) perContact.get(id).svMonths.add(mk);
          }
        }
      });
      monthOptions=monthSet;

      deals.forEach(d=>{
        const c=matchDealToContact(d, idx); if(!c) return;
        const cid=norm(c['Record ID']); if(!cid||!contactInfo.has(cid)) return;
        const mk=contactInfo.get(cid).createMonth;
        if(!perContact.has(cid)) perContact.set(cid,{svMonths:new Set(), closedMonths:new Set(), wonMonths:new Set(), totalWon:0});
        const pc=perContact.get(cid);
        const amt=parseFloat((d['Amount']||d['AMOUNT']||d['amount']||'0').toString().replace(/[^0-9.\-]/g,''))||0;
        const stage=lc(d['Deal Stage']||d['DEAL STAGE']||d['deal stage']);
        if(mk && stage.includes('closed')) pc.closedMonths.add(mk);
        const isClosedWon = stage.includes('closed won');
        if(mk && isClosedWon) pc.wonMonths.add(mk);
        if(isClosedWon){ pc.totalWon += amt; }
      });

      perContact.forEach((pc, cid) => {
        const info = contactInfo.get(cid);
        if(!info) return;
        const mk = info.createMonth;
        if(!mk) return;
        if(info.channel === 'Meta Ads'){
          const camp = (info.fbCampaign || 'Unspecified').toString().trim();
          if(!metaCampaign[mk]) metaCampaign[mk] = {};
          if(!metaCampaign[mk][camp]) metaCampaign[mk][camp] = {leads:0,sv:0,closed:0,won:0,spend:0,dealSize:0};
          if(pc.svMonths.has(mk)) metaCampaign[mk][camp].sv++;
          if(pc.closedMonths.has(mk)) metaCampaign[mk][camp].closed++;
          if(pc.wonMonths.has(mk)) metaCampaign[mk][camp].won++;
          metaCampaign[mk][camp].dealSize += pc.totalWon;
        }
      });

      const spendMonth={
        'Meta Ads': monthSpendFromRows(spend.Meta,'Meta'),
        'Google Ads': monthSpendFromRows(spend.Google,'Google'),
        'Bing Ads': monthSpendFromRows(spend.Bing,'Bing'),
        'Thumbtack': monthSpendFromRows(spend.Thumbtack,'Thumbtack'),
        'Angi': {},
        'Referral': {},
        'Boostmaps':{}
      };
      Object.entries(metaSpendCampaign).forEach(([mk,obj])=>{
        Object.entries(obj).forEach(([camp,amt])=>{
          if(!metaCampaign[mk]) metaCampaign[mk]={};
          if(!metaCampaign[mk][camp]) metaCampaign[mk][camp] = {leads:0,sv:0,closed:0,won:0,spend:0,dealSize:0};
          metaCampaign[mk][camp].spend += amt;
        });
      });

      datasets={}; monthOptions.forEach(mk=>{
        ['Meta Ads','Google Ads','Bing Ads','Thumbtack','Angi','Referral','Boostmaps','Direct'].forEach(ch=>{
          if(!datasets[mk]) datasets[mk] = {};
          datasets[mk][ch] = {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
        });
      });
      const processedIDs = new Set();
      contacts.forEach(c=>{
        const id = norm(c['Record ID']); if(!id) return;
        if(processedIDs.has(id)) return; processedIDs.add(id);
        const info = contactInfo.get(id); if(!info) return;
        const mk = info.createMonth; if(!mk || !datasets[mk]) return;
        const ch = info.channel;
        datasets[mk][ch].leads++;
        if(perContact.has(id)) datasets[mk][ch].dealSize += perContact.get(id).totalWon;
        if(perContact.has(id) && perContact.get(id).svMonths.has(mk)) datasets[mk][ch].sv++;
        if(perContact.has(id) && perContact.get(id).closedMonths.has(mk)) datasets[mk][ch].closed++;
        if(perContact.has(id) && perContact.get(id).wonMonths.has(mk)) datasets[mk][ch].won++;
      });
      Object.keys(datasets).forEach(mk=>{
        Object.keys(datasets[mk]).forEach(ch=>{
          let s=0;
          if(ch==='Meta Ads') s=spendMonth['Meta Ads'][mk]||0;
          if(ch==='Google Ads') s=spendMonth['Google Ads'][mk]||0;
          if(ch==='Bing Ads') s=spendMonth['Bing Ads'][mk]||0;
          if(ch==='Thumbtack') s=spendMonth['Thumbtack'][mk]||0;
          if(ch==='Angi'){
            // Angi has a flat monthly spend of $1050 starting in September 2025.  Before that the
            // spend is 0 since there is no Angi cost prior to Sep 2025.  Use the month key
            // string (yyyy-LL) to compare lexically with "2025-09".
            s = (mk && mk >= '2025-09') ? 1050 : 0;
          } else if(ch==='Referral'){
            s = spendMonth['Referral'][mk]||0;
          } else if(ch==='Boostmaps'){
            // Boostmaps spend is $900 per month through August 2025, and increases to $2100
            // starting in September 2025.  Compare the month key to "2025-09" to determine
            // which rate applies.
            s = (mk && mk >= '2025-09') ? 2100 : 900;
          }
          datasets[mk][ch].spend = s;
        });
      });

      document.getElementById('status').style.display='inline-block';
      // Populate both primary and comparison month selectors after data loads
      fillMonthOptions();
      fillCompareMonthOptions();
      fillCampaignOptions();
      render();
    } catch(e){ console.error(e); const el=document.getElementById('error'); el.style.display='inline-block'; el.textContent='‚ùå '+e.message; }
  });

  function fillMonthOptions(){
    const allTimeEl = document.getElementById('allTimeCb');
    // When the primary "All time" checkbox is toggled, clear any specific month selections and re-render.
    if(allTimeEl) allTimeEl.addEventListener('change', () => {
      if(allTimeEl.checked){
        // Uncheck all month checkboxes when selecting All time
        const monthCbs = container.querySelectorAll('input[type="checkbox"]');
        monthCbs.forEach(cb => { cb.checked = false; });
      }
      render();
    });
    const container = document.getElementById('monthCheckboxes');
    container.innerHTML = '';
    const months = Array.from(monthOptions).sort();
    months.forEach(m => {
      const wrapper = document.createElement('label');
      wrapper.style.display='inline-flex'; wrapper.style.alignItems='center'; wrapper.style.marginRight='8px';
      const cb = document.createElement('input');
      cb.type='checkbox';
      cb.value = m;
      cb.addEventListener('change', () => {
        // When a specific month is selected, uncheck the primary "All time" checkbox
        const at = document.getElementById('allTimeCb');
        if(cb.checked && at){ at.checked = false; }
        fillCampaignOptions();
        render();
      });
      const text = document.createElement('span'); text.style.marginLeft='4px';
      try{ text.textContent = DateTime.fromFormat(m, 'yyyy-LL').toFormat('LLLL yyyy'); } catch{ text.textContent=m; }
      wrapper.appendChild(cb); wrapper.appendChild(text); container.appendChild(wrapper);
    });
  }

  // Populate the secondary month filter for comparison. Similar to fillMonthOptions(),
  // this creates a second set of month checkboxes and an All time toggle for
  // comparison. Selecting any of these will trigger a re-render.  Use this to
  // choose a second date range to compare against the primary range.
  function fillCompareMonthOptions(){
    const compareAllTimeEl = document.getElementById('compareAllTimeCb');
    // When the comparison "All time" checkbox is toggled, clear any specific comparison month selections and re-render.
    if(compareAllTimeEl) compareAllTimeEl.addEventListener('change', () => {
      if(compareAllTimeEl.checked){
        const monthCbs2 = container.querySelectorAll('input[type="checkbox"]');
        monthCbs2.forEach(cb => { cb.checked = false; });
      }
      render();
    });
    const container = document.getElementById('compareMonthCheckboxes');
    if(!container) return;
    container.innerHTML = '';
    const months = Array.from(monthOptions).sort();
    months.forEach(m => {
      const wrapper = document.createElement('label');
      wrapper.style.display='inline-flex';
      wrapper.style.alignItems='center';
      wrapper.style.marginRight='8px';
      const cb = document.createElement('input');
      cb.type='checkbox';
      cb.value = m;
      cb.addEventListener('change', () => {
        // When a comparison month is selected, uncheck the comparison "All time" checkbox
        const at2 = document.getElementById('compareAllTimeCb');
        if(cb.checked && at2){ at2.checked = false; }
        render();
      });
      const text = document.createElement('span');
      text.style.marginLeft='4px';
      try{
        text.textContent = DateTime.fromFormat(m, 'yyyy-LL').toFormat('LLLL yyyy');
      } catch{
        text.textContent = m;
      }
      wrapper.appendChild(cb);
      wrapper.appendChild(text);
      container.appendChild(wrapper);
    });
  }

  function fillCampaignOptions(){
    const selectedChannels = Array.from(document.querySelectorAll('#channelCheckboxes input:checked')).map(cb=>cb.value);
    const campaignRow = document.getElementById('campaignRow');
    const cont = document.getElementById('campaignCheckboxes');
    // Hide the campaign row unless exactly one channel is selected and it is Meta Ads
    if(!(selectedChannels.length === 1 && selectedChannels[0] === 'Meta Ads')){
      if(campaignRow) campaignRow.style.display='none';
      return;
    }
    // Show the campaign row
    if(campaignRow) campaignRow.style.display='flex';
    // Determine months to inspect for available campaigns (use selected months or all months when no selection)
    const selectedMonths = Array.from(document.querySelectorAll('#monthCheckboxes input:checked')).map(cb => cb.value);
    const months = selectedMonths.length === 0 ? Object.keys(metaCampaign) : selectedMonths;
    const campaigns=new Set();
    months.forEach(mk=>{
      const obj=metaCampaign[mk]||{};
      Object.keys(obj).forEach(c=>{ const data=obj[c]; if(data && data.leads>0) campaigns.add(c); });
    });
    // Remember previously selected campaigns to preserve user choices when the list changes
    const prevSelected = Array.from(cont.querySelectorAll('input:checked')).map(cb => cb.value);
    cont.innerHTML='';
    // Create "All" checkbox
    const allLabel = document.createElement('label');
    const allInput = document.createElement('input');
    allInput.type='checkbox';
    allInput.value='all';
    // If no previous selection or previous selection includes "all", default to checked
    allInput.checked = (prevSelected.length === 0 || prevSelected.includes('all'));
    allLabel.appendChild(allInput);
    const allSpan = document.createElement('span');
    allSpan.style.marginLeft='4px';
    allSpan.textContent = 'All Campaigns';
    allLabel.appendChild(allSpan);
    cont.appendChild(allLabel);
    // Create checkboxes for each campaign
    [...campaigns].sort().forEach((c, idx) => {
      const label = document.createElement('label');
      const input = document.createElement('input');
      input.type='checkbox';
      input.value = c;
      // Check if previously selected
      input.checked = prevSelected.includes(c) && !prevSelected.includes('all');
      label.appendChild(input);
      const span = document.createElement('span');
      span.style.marginLeft='4px';
      span.textContent = c;
      label.appendChild(span);
      cont.appendChild(label);
    });
    // Add mutual exclusivity for the campaign checkboxes
    const updateCampaignChecks = () => {
      const inputs = cont.querySelectorAll('input');
      const allCb = cont.querySelector('input[value="all"]');
      const others = Array.from(inputs).filter(cb => cb.value !== 'all');
      // When "all" is checked, uncheck any individual campaign selections
      if(allCb && allCb.checked){
        others.forEach(cb => { cb.checked = false; });
      } else {
        // If any individual campaign is selected, ensure the "all" checkbox is unchecked
        if(others.some(cb => cb.checked)){
          if(allCb) allCb.checked = false;
        }
      }
      // We intentionally do not force a selection when all boxes are unchecked.  An empty
      // selection implies the user wants to view aggregated data across all campaigns.
      render();
    };
    // Assign event listeners
    const allCb = cont.querySelector('input[value="all"]');
    if(allCb){
      allCb.addEventListener('change', updateCampaignChecks);
    }
    cont.querySelectorAll('input').forEach(cb => {
      if(cb.value !== 'all'){
        cb.addEventListener('change', updateCampaignChecks);
      }
    });
  }

  // Color mapping for channels including Angi and Referral
  const colorMap = {
    'Meta Ads':'#2563eb',
    'Google Ads':'#f97316',
    'Bing Ads':'#16a34a',
    'Thumbtack':'#f59e0b',
    'Angi':'#0ea5a0',
    'Referral':'#7c3aed',
    'Boostmaps':'#ec4899',
    'Direct':'#8b5cf6',
    'all':'#2563eb'
  };

  // When multiple Meta Ads campaigns are selected, assign each campaign a distinct base color
  // from this palette instead of just lightening the same blue.  The palette includes red,
  // green, yellow, purple, pink, orange, cyan, and indigo to make lines clearly distinguishable.
  const metaPalette = [
    '#ef4444', // red
    '#10b981', // green
    '#fbbf24', // yellow
    '#a855f7', // purple
    '#ec4899', // pink
    '#f97316', // orange
    '#22d3ee', // cyan
    '#8b5cf6'  // indigo
  ];
  function lightenColor(hex, percent){
    hex = hex.replace('#',''); const num = parseInt(hex, 16); const amt = Math.round(2.55 * percent);
    let R = (num >> 16) + amt; let G = (num >> 8 & 0x00FF) + amt; let B = (num & 0x0000FF) + amt;
    R = R < 255 ? (R < 0 ? 0 : R) : 255; G = G < 255 ? (G < 0 ? 0 : G) : 255; B = B < 255 ? (B < 0 ? 0 : B) : 255;
    return '#' + (0x1000000 + (R * 0x10000) + (G * 0x100) + B).toString(16).slice(1);
  }
  function seriesFor(months, channel, key, campaignSelection=null){
    return months.map(m => {
      // For Meta Ads, allow multi-campaign selection (array). If 'all' is selected or no specific campaigns provided, sum all campaigns.
      if(channel === 'Meta Ads'){
        // If an array of selected campaigns is provided and doesn't include 'all'
        if(Array.isArray(campaignSelection) && campaignSelection.length > 0 && !campaignSelection.includes('all')){
          return campaignSelection.reduce((sum, campName) => {
            const data = (metaCampaign[m]?.[campName]) || {};
            return sum + (data[key] || 0);
          }, 0);
        }
        // If 'all' is selected or no specific selection, sum across all campaigns for this month
        const campaignsObj = metaCampaign[m] || {};
        return Object.values(campaignsObj).reduce((sum, data) => sum + (data[key] || 0), 0);
      }
      // For aggregated (channel === 'all') or other channels, use existing logic
      const val = channel === 'all'
        ? Object.values(datasets[m] || {}).reduce((a, x) => a + (x[key] || 0), 0)
        : (datasets[m]?.[channel]?.[key] || 0);
      return val;
    });
  }

  let ch1,ch2,ch3,ch4,ch5,ch6,ch7;
  function render(){
    // Determine the primary and comparison month ranges. The primary range is controlled by the main
    // month checkboxes and All time toggle; the comparison range is controlled by the secondary set.
    const allTime1 = document.getElementById('allTimeCb')?.checked;
    const selectedMonths1Arr = Array.from(document.querySelectorAll('#monthCheckboxes input:checked')).map(cb => cb.value);
    // Determine the primary date range.  If "All time" is selected, use all available months.  If
    // no months are selected and "All time" is unchecked, treat the range as empty (no data).
    const months1 = allTime1 ? Object.keys(datasets).sort() : (selectedMonths1Arr.length > 0 ? selectedMonths1Arr : []);
    const compareAllTime = document.getElementById('compareAllTimeCb')?.checked;
    const selectedCompareMonthsArr = Array.from(document.querySelectorAll('#compareMonthCheckboxes input:checked')).map(cb => cb.value);
    // Determine the comparison date range.  If "All time" is selected for the comparison, use all
    // available months.  If no months are selected and the comparison "All time" is unchecked,
    // treat the comparison range as empty, so R2 metrics will not be shown.
    const months2 = compareAllTime ? Object.keys(datasets).sort() : (selectedCompareMonthsArr.length > 0 ? selectedCompareMonthsArr : []);
    // The full set of months used for charts is the union of both ranges
    // For comparison, we limit chart labels to the primary range (months1).  The comparison
    // range (months2) is still used to compute difference datasets, but extra months
    // outside the primary range will not appear on the x-axis.  This keeps the
    // number of labels consistent with the primary selection and simplifies chart
    // rendering.  If you need to show months unique to the comparison range, you
    // could compute a union here instead.
    const displayMonths = months1;
    // For backward compatibility, assign months to months1 so that aggregated metrics and table
    // operate on the primary range.
    const months = months1;
    const selectedChannelsArr = Array.from(document.querySelectorAll('#channelCheckboxes input:checked')).map(cb => cb.value);
    const allChannels = ['Meta Ads','Google Ads','Bing Ads','Thumbtack','Angi','Referral','Boostmaps','Direct'];
    const channels = (selectedChannelsArr.includes('all') || selectedChannelsArr.length === 0) ? allChannels : selectedChannelsArr;
    // Collect selected campaigns from the multi-select. If "all" is selected (or no specific campaigns selected), treat as all campaigns.
    // Collect selected campaigns from the campaign checkboxes.  When the campaign row
    // is hidden or no campaigns are selected, this yields an empty array.  When
    // "all" is checked, the value will be 'all'.
    let selectedCampaigns = [];
    const campaignInputs = document.querySelectorAll('#campaignCheckboxes input:checked');
    if(campaignInputs.length > 0){
      selectedCampaigns = Array.from(campaignInputs).map(cb => cb.value);
    }

    // Helper to map series values for a given range (monthsRange) onto the displayMonths array.  It
    // builds a lookup table keyed by month and then produces an array aligned with displayMonths,
    // inserting nulls for months outside the provided range.  This ensures that all data arrays
    // have the same length as the labels array.  The campaignSel parameter is passed to seriesFor
    // to handle Meta Ads campaign selection.
    const getSeriesForDisplayRange = (channel, key, monthsRange, campaignSel) => {
      const arr = seriesFor(monthsRange, channel, key, campaignSel);
      const map = {};
      monthsRange.forEach((m, idx) => { map[m] = arr[idx]; });
      return months.map(m => (map.hasOwnProperty(m) ? map[m] : null));
    };
    // Base color used for difference datasets (grey).  Lighter variants are derived using
    // lightenColor().
    const diffColor = '#6b7280';
    
    let agg = {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
    let rows = [];
    months.forEach(m => {
      channels.forEach(ch => {
        let d;
        if(ch === 'Meta Ads' && selectedCampaigns.length > 0 && !selectedCampaigns.includes('all')){
          // Combine metrics across the selected campaigns for Meta Ads
          const combined = {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
          selectedCampaigns.forEach(campName => {
            const data = (metaCampaign[m]?.[campName]) || {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
            combined.leads += data.leads;
            combined.sv += data.sv;
            combined.closed += data.closed;
            combined.won += data.won;
            combined.spend += data.spend;
            combined.dealSize += data.dealSize;
          });
          d = combined;
        } else if(ch === 'Meta Ads' && selectedCampaigns.includes('all')){
          // All campaigns selected: aggregate across all campaigns for this month
          const aggData = {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
          const campaignsObj = metaCampaign[m] || {};
          Object.values(campaignsObj).forEach(val => {
            aggData.leads += val.leads || 0;
            aggData.sv += val.sv || 0;
            aggData.closed += val.closed || 0;
            aggData.won += val.won || 0;
            aggData.spend += val.spend || 0;
            aggData.dealSize += val.dealSize || 0;
          });
          d = aggData;
        } else {
          d = datasets[m]?.[ch] || {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
        }
        // Build channel label: for Meta Ads with selected campaigns, append campaign names (comma-separated) if not selecting all
        let channelLabel = ch;
        if(ch === 'Meta Ads' && Array.isArray(selectedCampaigns) && selectedCampaigns.length > 0 && !selectedCampaigns.includes('all')){
          channelLabel += ' (' + selectedCampaigns.join(', ') + ')';
        }
        rows.push({ month:m, channel: channelLabel,
          leads:d.leads, sv:d.sv, closed:d.closed, won:d.won, spend:d.spend,
          cpl: d.leads ? d.spend/d.leads : 0, cpsv: d.sv ? d.spend/d.sv : 0, dealSize:d.dealSize });
        agg.leads+=d.leads; agg.sv+=d.sv; agg.closed+=d.closed; agg.won+=d.won; agg.spend+=d.spend; agg.dealSize+=d.dealSize;
      });
    });

    // Compute aggregated metrics for the comparison range (months2).  This mirrors the logic used
    // above for the primary range.  We iterate over the selected channels and sum metrics across
    // all months in the comparison range.  The same rules for Meta Ads campaign selection
    // apply here, aggregating across selected campaigns or across all campaigns when 'all' is
    // selected.  The resulting agg2 object contains totals for leads, site visits, closed deals,
    // won deals, spend, and deal size.  These values are then used to display comparison
    // metrics alongside the primary range metrics in the dashboard cards.
    let agg2 = {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
    months2.forEach(m => {
      channels.forEach(ch => {
        let d2;
        if(ch === 'Meta Ads' && Array.isArray(selectedCampaigns) && selectedCampaigns.length > 0 && !selectedCampaigns.includes('all')){
          // Combine metrics across the selected campaigns for Meta Ads
          const combined2 = {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
          selectedCampaigns.forEach(campName => {
            const data2 = (metaCampaign[m]?.[campName]) || {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
            combined2.leads += data2.leads;
            combined2.sv += data2.sv;
            combined2.closed += data2.closed;
            combined2.won += data2.won;
            combined2.spend += data2.spend;
            combined2.dealSize += data2.dealSize;
          });
          d2 = combined2;
        } else if(ch === 'Meta Ads' && Array.isArray(selectedCampaigns) && selectedCampaigns.includes('all')){
          // All campaigns selected: aggregate across all campaigns for this month
          const combined2 = {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
          const campaignsObj2 = metaCampaign[m] || {};
          Object.values(campaignsObj2).forEach(val2 => {
            combined2.leads += val2.leads || 0;
            combined2.sv += val2.sv || 0;
            combined2.closed += val2.closed || 0;
            combined2.won += val2.won || 0;
            combined2.spend += val2.spend || 0;
            combined2.dealSize += val2.dealSize || 0;
          });
          d2 = combined2;
        } else {
          // Non-Meta channel
          d2 = datasets[m]?.[ch] || {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
        }
        agg2.leads += d2.leads;
        agg2.sv    += d2.sv;
        agg2.closed += d2.closed;
        agg2.won   += d2.won;
        agg2.spend += d2.spend;
        agg2.dealSize += d2.dealSize;
      });
    });

    const money = n => '$' + (n || 0).toLocaleString(undefined, { maximumFractionDigits: 2 });
    const pct = n => (n || 0).toFixed(1) + '%';
    // Update the metric cards to show both primary (R1) and comparison (R2) values separated by a bar.
    // Helper to compute percentage change between two values.  If invert is true, a larger
    // value in the comparison range is considered negative (used for cost metrics and spend).
    function computeDiff(val1, val2, invert){
      // If both values are zero, return neutral 0%
      if(val1 === 0 && val2 === 0) return {text:'0%', className:'diff-neutral'};
      let diff;
      // Handle division by zero: if val1 is zero and val2 > 0, treat as 100% increase;
      // if val1 is zero and val2 < 0, treat as 100% decrease (though this case rarely occurs).
      if(val1 === 0){
        diff = val2 > 0 ? 100 : val2 < 0 ? -100 : 0;
      } else {
        diff = ((val2 - val1) / Math.abs(val1)) * 100;
      }
      // Determine class name based on whether we are inverting the interpretation of the change.  For
      // cost metrics (invert=true), cost increases (positive diff) are bad and should be red, while
      // decreases (negative diff) are good and should be green.  For non-cost metrics, the opposite
      // applies: increases are good and decreases are bad.
      let cls;
      if(invert){
        if(diff > 0) cls = 'diff-negative';
        else if(diff < 0) cls = 'diff-positive';
        else cls = 'diff-neutral';
      } else {
        if(diff > 0) cls = 'diff-positive';
        else if(diff < 0) cls = 'diff-negative';
        else cls = 'diff-neutral';
      }
      const sign = diff >= 0 ? '+' : '-';
      return {text: `${sign}${Math.abs(diff).toFixed(1)}%`, className: cls};
    }
    // Compute values needed for difference calculations
    const cplR1 = agg.leads ? agg.spend / agg.leads : 0;
    const cplR2 = agg2.leads ? agg2.spend / agg2.leads : 0;
    const cpsvR1 = agg.sv ? agg.spend / agg.sv : 0;
    const cpsvR2 = agg2.sv ? agg2.spend / agg2.sv : 0;
    const avgDealR1 = agg.leads ? agg.dealSize / agg.leads : 0;
    const avgDealR2 = agg2.leads ? agg2.dealSize / agg2.leads : 0;
    const costPerDealR1 = agg.won ? agg.spend / agg.won : 0;
    const costPerDealR2 = agg2.won ? agg2.spend / agg2.won : 0;
    const marketingProfitR1 = avgDealR1 - costPerDealR1;
    const marketingProfitR2 = avgDealR2 - costPerDealR2;
    const dealConvR1 = agg.leads ? (agg.won / agg.leads * 100) : 0;
    const dealConvR2 = agg2.leads ? (agg2.won / agg2.leads * 100) : 0;
    // Compute percentage differences for each metric
    const leadsDiff = computeDiff(agg.leads, agg2.leads, false);
    const svDiff = computeDiff(agg.sv, agg2.sv, false);
    const svConvDiff = computeDiff( agg.leads ? (agg.sv / agg.leads) : 0, agg2.leads ? (agg2.sv / agg2.leads) : 0, false);
    const dealSizeDiff = computeDiff(agg.dealSize, agg2.dealSize, false);
    const closedDiff = computeDiff(agg.closed, agg2.closed, false);
    const wonDiff = computeDiff(agg.won, agg2.won, false);
    const spendDiff = computeDiff(agg.spend, agg2.spend, true);
    const cplDiff = computeDiff(cplR1, cplR2, true);
    const cpsvDiff = computeDiff(cpsvR1, cpsvR2, true);
    const costPerDealDiff = computeDiff(costPerDealR1, costPerDealR2, true);
    const avgDealDiff = computeDiff(avgDealR1, avgDealR2, false);
    const marketingProfitDiff = computeDiff(marketingProfitR1, marketingProfitR2, false);
    const dealConvDiff = computeDiff(dealConvR1, dealConvR2, false);
    // Update metric displays.  If there is a comparison range selected (months2 not empty), show R1 and
    // R2 values and the percentage change.  Otherwise, show only the R1 value and omit R2 and diff.
    const hasComparison = months2.length > 0;
    const leadsEl   = document.getElementById('leadsNum');
    const svEl      = document.getElementById('svNum');
    const svConvEl  = document.getElementById('svConv');
    const dealSizeEl= document.getElementById('dealSize');
    const closedEl  = document.getElementById('closedNum');
    const wonEl     = document.getElementById('wonNum');
    const spendEl   = document.getElementById('spend');
    const cplEl     = document.getElementById('cpl');
    const cpsvEl    = document.getElementById('cpsv');
    const avgDealEl = document.getElementById('avgDealVal');
    const costDealEl= document.getElementById('costPerDeal');
    const profitEl  = document.getElementById('marketingProfit');
    const dealConvEl= document.getElementById('dealConv');
    if(hasComparison){
      leadsEl.innerHTML    = agg.leads.toLocaleString() + ' | ' + agg2.leads.toLocaleString()    + ' <span class="' + leadsDiff.className    + '">(' + leadsDiff.text    + ')</span>';
      svEl.innerHTML       = agg.sv.toLocaleString()    + ' | ' + agg2.sv.toLocaleString()       + ' <span class="' + svDiff.className       + '">(' + svDiff.text       + ')</span>';
      svConvEl.innerHTML   = pct(agg.leads ? (agg.sv / agg.leads * 100) : 0) + ' | ' + pct(agg2.leads ? (agg2.sv / agg2.leads * 100) : 0) + ' <span class="' + svConvDiff.className   + '">(' + svConvDiff.text   + ')</span>';
      dealSizeEl.innerHTML = money(agg.dealSize) + ' | ' + money(agg2.dealSize) + ' <span class="' + dealSizeDiff.className + '">(' + dealSizeDiff.text + ')</span>';
      closedEl.innerHTML   = agg.closed.toLocaleString() + ' | ' + agg2.closed.toLocaleString() + ' <span class="' + closedDiff.className   + '">(' + closedDiff.text   + ')</span>';
      wonEl.innerHTML      = agg.won.toLocaleString()   + ' | ' + agg2.won.toLocaleString()   + ' <span class="' + wonDiff.className      + '">(' + wonDiff.text      + ')</span>';
      spendEl.innerHTML    = money(agg.spend) + ' | ' + money(agg2.spend) + ' <span class="' + spendDiff.className    + '">(' + spendDiff.text    + ')</span>';
      cplEl.innerHTML      = money(cplR1) + ' | ' + money(cplR2) + ' <span class="' + cplDiff.className      + '">(' + cplDiff.text      + ')</span>';
      cpsvEl.innerHTML     = money(cpsvR1) + ' | ' + money(cpsvR2) + ' <span class="' + cpsvDiff.className     + '">(' + cpsvDiff.text     + ')</span>';
      avgDealEl.innerHTML  = money(avgDealR1) + ' | ' + money(avgDealR2) + ' <span class="' + avgDealDiff.className  + '">(' + avgDealDiff.text  + ')</span>';
      costDealEl.innerHTML = money(costPerDealR1) + ' | ' + money(costPerDealR2) + ' <span class="' + costPerDealDiff.className + '">(' + costPerDealDiff.text + ')</span>';
      profitEl.innerHTML   = money(marketingProfitR1) + ' | ' + money(marketingProfitR2) + ' <span class="' + marketingProfitDiff.className + '">(' + marketingProfitDiff.text + ')</span>';
      dealConvEl.innerHTML = pct(dealConvR1) + ' | ' + pct(dealConvR2) + ' <span class="' + dealConvDiff.className + '">(' + dealConvDiff.text + ')</span>';
    } else {
      // Only show R1 values when there is no comparison range selected
      leadsEl.textContent    = agg.leads.toLocaleString();
      svEl.textContent       = agg.sv.toLocaleString();
      svConvEl.textContent   = pct(agg.leads ? (agg.sv / agg.leads * 100) : 0);
      dealSizeEl.textContent = money(agg.dealSize);
      closedEl.textContent   = agg.closed.toLocaleString();
      wonEl.textContent      = agg.won.toLocaleString();
      spendEl.textContent    = money(agg.spend);
      cplEl.textContent      = money(cplR1);
      cpsvEl.textContent     = money(cpsvR1);
      avgDealEl.textContent  = money(avgDealR1);
      costDealEl.textContent = money(costPerDealR1);
      profitEl.textContent   = money(marketingProfitR1);
      dealConvEl.textContent = pct(dealConvR1);
    }

    const tb = document.querySelector('#detailTbl tbody'); tb.innerHTML='';
    rows.forEach(r => {
      const tr = document.createElement('tr');
      let human; try { human = DateTime.fromFormat(r.month, 'yyyy-LL').toFormat('LLLL yyyy'); } catch { human = r.month; }
      tr.innerHTML = `<td>${human}</td><td>${r.channel}</td><td>${r.leads}</td><td>${r.sv}</td><td>${r.closed}</td><td>${r.won}</td><td>${money(r.spend)}</td><td>${r.leads ? money(r.spend / r.leads) : "$0"}</td><td>${r.sv ? money(r.spend / r.sv) : "$0"}</td><td>${money(r.dealSize)}</td>`;
      tb.appendChild(tr);
    });

    // Build labels based on the union of months from both ranges
    const labels = displayMonths.map(m => { try { return DateTime.fromFormat(m, 'yyyy-LL').toFormat('LLL yy'); } catch { return m; } });
    if(ch1) ch1.destroy(); if(ch2) ch2.destroy(); if(ch3) ch3.destroy(); if(ch4) ch4.destroy(); if(ch5) ch5.destroy(); if(ch6) ch6.destroy(); if(ch7) ch7.destroy();
    const useAggregated = (selectedChannelsArr.includes('all') || selectedChannelsArr.length === 0);

    // Trend 1: Leads / Site Visits / Won
    const chart1Datasets = [];
    if(useAggregated){
      // Aggregated view across all channels: treat Meta Ads aggregated across selected campaigns
      (useAggregated ? ['all'] : channels).forEach(ch => {
        const base = colorMap[ch] || colorMap['all'];
        chart1Datasets.push({ label: (useAggregated?'All Channels':'') + (useAggregated?'':' '+ch) + ' Leads', data: seriesFor(months, ch, 'leads', selectedCampaigns), tension:.3, borderColor: base, backgroundColor: base+'33' });
        chart1Datasets.push({ label: (useAggregated?'All Channels':'') + (useAggregated?'':' '+ch) + ' Site Visits', data: seriesFor(months, ch, 'sv', selectedCampaigns), tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
        chart1Datasets.push({ label: (useAggregated?'All Channels':'') + (useAggregated?'':' '+ch) + ' Won Deals', data: seriesFor(months, ch, 'won', selectedCampaigns), tension:.3, borderColor: lightenColor(base, 50), backgroundColor: lightenColor(base, 50)+'33', borderDash:[4,4] });
      });
    } else {
      // Detailed view: show each selected Meta campaign separately
      channels.forEach(ch => {
        if(ch === 'Meta Ads'){
          // Determine campaigns to display individually (exclude 'all')
          const campaignsForDisplay = Array.isArray(selectedCampaigns) ? selectedCampaigns.filter(c => c !== 'all') : [];
          const base = colorMap['Meta Ads'] || colorMap['all'];
          if(campaignsForDisplay.length > 0){
            // Combined data across selected campaigns
            const leadsAgg = seriesFor(months, 'Meta Ads', 'leads', selectedCampaigns);
            const svAgg = seriesFor(months, 'Meta Ads', 'sv', selectedCampaigns);
            const wonAgg = seriesFor(months, 'Meta Ads', 'won', selectedCampaigns);
            chart1Datasets.push({ label: 'Meta Ads (Combined) Leads', data: leadsAgg, tension:.3, borderColor: base, backgroundColor: base+'33' });
            chart1Datasets.push({ label: 'Meta Ads (Combined) Site Visits', data: svAgg, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
            chart1Datasets.push({ label: 'Meta Ads (Combined) Won Deals', data: wonAgg, tension:.3, borderColor: lightenColor(base, 50), backgroundColor: lightenColor(base, 50)+'33', borderDash:[4,4] });
            // Individual campaigns
            campaignsForDisplay.forEach((cn, idx) => {
              // Select a distinct base color for each campaign from the metaPalette
              const colorVar = metaPalette[idx % metaPalette.length];
              chart1Datasets.push({ label: 'Meta Ads - ' + cn + ' Leads', data: seriesFor(months, 'Meta Ads', 'leads', [cn]), tension:.3, borderColor: colorVar, backgroundColor: colorVar+'33' });
              chart1Datasets.push({ label: 'Meta Ads - ' + cn + ' Site Visits', data: seriesFor(months, 'Meta Ads', 'sv', [cn]), tension:.3, borderColor: lightenColor(colorVar, 30), backgroundColor: lightenColor(colorVar, 30)+'33', borderDash:[6,4] });
              chart1Datasets.push({ label: 'Meta Ads - ' + cn + ' Won Deals', data: seriesFor(months, 'Meta Ads', 'won', [cn]), tension:.3, borderColor: lightenColor(colorVar, 50), backgroundColor: lightenColor(colorVar, 50)+'33', borderDash:[4,4] });
            });
          } else {
            // No specific campaigns selected; treat all campaigns as one aggregated dataset
            const leadsAll = seriesFor(months, 'Meta Ads', 'leads', selectedCampaigns);
            const svAll = seriesFor(months, 'Meta Ads', 'sv', selectedCampaigns);
            const wonAll = seriesFor(months, 'Meta Ads', 'won', selectedCampaigns);
            chart1Datasets.push({ label: 'Meta Ads Leads', data: leadsAll, tension:.3, borderColor: base, backgroundColor: base+'33' });
            chart1Datasets.push({ label: 'Meta Ads Site Visits', data: svAll, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
            chart1Datasets.push({ label: 'Meta Ads Won Deals', data: wonAll, tension:.3, borderColor: lightenColor(base, 50), backgroundColor: lightenColor(base, 50)+'33', borderDash:[4,4] });
          }
        } else {
          // Non-Meta channel
          const base = colorMap[ch] || colorMap['all'];
          chart1Datasets.push({ label: ch + ' Leads', data: seriesFor(months, ch, 'leads', selectedCampaigns), tension:.3, borderColor: base, backgroundColor: base+'33' });
          chart1Datasets.push({ label: ch + ' Site Visits', data: seriesFor(months, ch, 'sv', selectedCampaigns), tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
          chart1Datasets.push({ label: ch + ' Won Deals', data: seriesFor(months, ch, 'won', selectedCampaigns), tension:.3, borderColor: lightenColor(base, 50), backgroundColor: lightenColor(base, 50)+'33', borderDash:[4,4] });
        }
      });
    }
    ch1 = new Chart(document.getElementById('trend1'), { type:'line', data:{labels, datasets:chart1Datasets}, options:{responsive:true, scales:{y:{beginAtZero:true}}} });

    // Trend 2: Spend
    const chart2Datasets = [];
    if(useAggregated){
      (useAggregated ? ['all'] : channels).forEach(ch => {
        const base = colorMap[ch] || colorMap['all'];
        chart2Datasets.push({ label: (useAggregated?'All Channels':'') + (useAggregated?'':' '+ch) + ' Spend ($)', data: seriesFor(months, ch, 'spend', selectedCampaigns), tension:.3, borderColor: base, backgroundColor: base+'33' });
      });
    } else {
      channels.forEach(ch => {
        if(ch === 'Meta Ads'){
          const campaignsForDisplay = Array.isArray(selectedCampaigns) ? selectedCampaigns.filter(c => c !== 'all') : [];
          const base = colorMap['Meta Ads'] || colorMap['all'];
          if(campaignsForDisplay.length > 0){
            // Combined spend across selected campaigns
            const combinedSpend = seriesFor(months, 'Meta Ads', 'spend', selectedCampaigns);
            chart2Datasets.push({ label:'Meta Ads (Combined) Spend ($)', data: combinedSpend, tension:.3, borderColor: base, backgroundColor: base+'33' });
            campaignsForDisplay.forEach((cn, idx) => {
              // Select a distinct base color for each campaign from the metaPalette
              const colorVar = metaPalette[idx % metaPalette.length];
              chart2Datasets.push({ label:'Meta Ads - '+cn+' Spend ($)', data: seriesFor(months, 'Meta Ads', 'spend', [cn]), tension:.3, borderColor: colorVar, backgroundColor: colorVar+'33' });
            });
          } else {
            // No specific campaigns selected: show aggregated spend across all campaigns
            const spendAll = seriesFor(months, 'Meta Ads', 'spend', selectedCampaigns);
            chart2Datasets.push({ label:'Meta Ads Spend ($)', data: spendAll, tension:.3, borderColor: base, backgroundColor: base+'33' });
          }
        } else {
          const base = colorMap[ch] || colorMap['all'];
          chart2Datasets.push({ label: ch + ' Spend ($)', data: seriesFor(months, ch, 'spend', selectedCampaigns), tension:.3, borderColor: base, backgroundColor: base+'33' });
        }
      });
    }
    // Append a difference dataset aggregated across all channels (primary range minus comparison range)
    {
      const aggSpend1 = getSeriesForDisplayRange('all', 'spend', months1, selectedCampaigns);
      const aggSpend2 = getSeriesForDisplayRange('all', 'spend', months2, selectedCampaigns);
      const diffSpend = aggSpend1.map((v,i) => { const a = v || 0; const b = aggSpend2[i] || 0; return a - b; });
      chart2Datasets.push({ label:'Spend Diff (R1-R2)', data: diffSpend, tension:.3, borderColor: diffColor, backgroundColor: diffColor+'33', borderDash:[3,3] });
    }
    ch2 = new Chart(document.getElementById('trend2'), { type:'line', data:{labels, datasets:chart2Datasets}, options:{responsive:true, scales:{y:{beginAtZero:true}}} });

    // Trend 3: CPL / CPSV
    const chart3Datasets = [];
    if(useAggregated){
      (useAggregated ? ['all'] : channels).forEach(ch => {
        const base = colorMap[ch] || colorMap['all'];
        const lighter = lightenColor(base, 30);
        const spendSeries = seriesFor(months, ch, 'spend', selectedCampaigns);
        const leadsSeries = seriesFor(months, ch, 'leads', selectedCampaigns);
        const svSeries = seriesFor(months, ch, 'sv', selectedCampaigns);
        const cplSeries = spendSeries.map((s,i)=>{ const l=leadsSeries[i]; return l ? s/l : 0; });
        const cpsvSeries = spendSeries.map((s,i)=>{ const v=svSeries[i]; return v ? s/v : 0; });
        chart3Datasets.push({ label: (useAggregated?'All Channels':'') + (useAggregated?'':' '+ch) + ' CPL', data:cplSeries, tension:.3, borderColor:base, backgroundColor:base+'33' });
        chart3Datasets.push({ label: (useAggregated?'All Channels':'') + (useAggregated?'':' '+ch) + ' CPSV', data:cpsvSeries, tension:.3, borderColor:lighter, backgroundColor:lighter+'33', borderDash:[6,4] });
      });
    } else {
      channels.forEach(ch => {
        if(ch === 'Meta Ads'){
          const campaignsForDisplay = Array.isArray(selectedCampaigns) ? selectedCampaigns.filter(c => c !== 'all') : [];
          const base = colorMap['Meta Ads'] || colorMap['all'];
          if(campaignsForDisplay.length > 0){
            // Combined CPL and CPSV across selected campaigns
            const spendAgg = seriesFor(months, 'Meta Ads', 'spend', selectedCampaigns);
            const leadsAgg = seriesFor(months, 'Meta Ads', 'leads', selectedCampaigns);
            const svAgg = seriesFor(months, 'Meta Ads', 'sv', selectedCampaigns);
            const cplAgg = spendAgg.map((s,i)=>{ const l = leadsAgg[i]; return l ? s/l : 0; });
            const cpsvAgg = spendAgg.map((s,i)=>{ const v = svAgg[i]; return v ? s/v : 0; });
            chart3Datasets.push({ label:'Meta Ads (Combined) CPL', data:cplAgg, tension:.3, borderColor: base, backgroundColor: base+'33' });
            chart3Datasets.push({ label:'Meta Ads (Combined) CPSV', data:cpsvAgg, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
            // Individual campaigns
            campaignsForDisplay.forEach((cn, idx) => {
              // Select a distinct base color for each campaign from the metaPalette
              const colorVar = metaPalette[idx % metaPalette.length];
              const spendS = seriesFor(months, 'Meta Ads', 'spend', [cn]);
              const leadsS = seriesFor(months, 'Meta Ads', 'leads', [cn]);
              const svS = seriesFor(months, 'Meta Ads', 'sv', [cn]);
              const cplS = spendS.map((s,i)=>{ const l = leadsS[i]; return l ? s/l : 0; });
              const cpsvS = spendS.map((s,i)=>{ const v = svS[i]; return v ? s/v : 0; });
              chart3Datasets.push({ label:'Meta Ads - '+cn+' CPL', data:cplS, tension:.3, borderColor: colorVar, backgroundColor: colorVar+'33' });
              chart3Datasets.push({ label:'Meta Ads - '+cn+' CPSV', data:cpsvS, tension:.3, borderColor: lightenColor(colorVar, 30), backgroundColor: lightenColor(colorVar, 30)+'33', borderDash:[6,4] });
            });
          } else {
            // No specific campaigns selected: aggregated across all campaigns
            const spendS = seriesFor(months, 'Meta Ads', 'spend', selectedCampaigns);
            const leadsS = seriesFor(months, 'Meta Ads', 'leads', selectedCampaigns);
            const svS = seriesFor(months, 'Meta Ads', 'sv', selectedCampaigns);
            const cplS = spendS.map((s,i)=>{ const l=leadsS[i]; return l ? s/l : 0; });
            const cpsvS = spendS.map((s,i)=>{ const v=svS[i]; return v ? s/v : 0; });
            chart3Datasets.push({ label:'Meta Ads CPL', data:cplS, tension:.3, borderColor: base, backgroundColor: base+'33' });
            chart3Datasets.push({ label:'Meta Ads CPSV', data:cpsvS, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
          }
        } else {
          const base = colorMap[ch] || colorMap['all'];
          const spendSeries = seriesFor(months, ch, 'spend', selectedCampaigns);
          const leadsSeries = seriesFor(months, ch, 'leads', selectedCampaigns);
          const svSeries = seriesFor(months, ch, 'sv', selectedCampaigns);
          const cplSeries = spendSeries.map((s,i)=>{ const l=leadsSeries[i]; return l ? s/l : 0; });
          const cpsvSeries = spendSeries.map((s,i)=>{ const v=svSeries[i]; return v ? s/v : 0; });
          chart3Datasets.push({ label: ch + ' CPL', data:cplSeries, tension:.3, borderColor: base, backgroundColor: base+'33' });
          chart3Datasets.push({ label: ch + ' CPSV', data:cpsvSeries, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
        }
      });
    }
    // Append difference datasets for cost metrics (CPL and CPSV) across all channels
    {
      const spendSeries1 = getSeriesForDisplayRange('all', 'spend', months1, selectedCampaigns);
      const spendSeries2 = getSeriesForDisplayRange('all', 'spend', months2, selectedCampaigns);
      const leadsSeries1 = getSeriesForDisplayRange('all', 'leads', months1, selectedCampaigns);
      const leadsSeries2 = getSeriesForDisplayRange('all', 'leads', months2, selectedCampaigns);
      const svSeries1 = getSeriesForDisplayRange('all', 'sv', months1, selectedCampaigns);
      const svSeries2 = getSeriesForDisplayRange('all', 'sv', months2, selectedCampaigns);
      const cpl1 = spendSeries1.map((s,i)=>{ const l = leadsSeries1[i]; return l ? s/l : 0; });
      const cpl2 = spendSeries2.map((s,i)=>{ const l = leadsSeries2[i]; return l ? s/l : 0; });
      const cpsv1 = spendSeries1.map((s,i)=>{ const v = svSeries1[i]; return v ? s/v : 0; });
      const cpsv2 = spendSeries2.map((s,i)=>{ const v = svSeries2[i]; return v ? s/v : 0; });
      const diffCpl = cpl1.map((v,i) => { const b = cpl2[i] || 0; return v - b; });
      const diffCpsv = cpsv1.map((v,i) => { const b = cpsv2[i] || 0; return v - b; });
      chart3Datasets.push({ label:'CPL Diff (R1-R2)', data: diffCpl, tension:.3, borderColor: diffColor, backgroundColor: diffColor+'33', borderDash:[3,3] });
      chart3Datasets.push({ label:'CPSV Diff (R1-R2)', data: diffCpsv, tension:.3, borderColor: lightenColor(diffColor, 30), backgroundColor: lightenColor(diffColor, 30)+'33', borderDash:[3,3] });
    }
    ch3 = new Chart(document.getElementById('trend3'), { type:'line', data:{labels, datasets:chart3Datasets}, options:{responsive:true, scales:{y:{beginAtZero:true}}} });

    // Trend 4: Deal Size
    const chart4Datasets = [];
    if(useAggregated){
      (useAggregated ? ['all'] : channels).forEach(ch => {
        const base = colorMap[ch] || colorMap['all'];
        chart4Datasets.push({ label: (useAggregated?'All Channels':'') + (useAggregated?'':' '+ch) + ' Deal Size ($)', data: seriesFor(months, ch, 'dealSize', selectedCampaigns), tension:.3, borderColor: base, backgroundColor: base+'33' });
      });
    } else {
      channels.forEach(ch => {
        if(ch === 'Meta Ads'){
          const campaignsForDisplay = Array.isArray(selectedCampaigns) ? selectedCampaigns.filter(c => c !== 'all') : [];
          const base = colorMap['Meta Ads'] || colorMap['all'];
          if(campaignsForDisplay.length > 0){
            // Combined deal size across selected campaigns
            const dsAgg = seriesFor(months, 'Meta Ads', 'dealSize', selectedCampaigns);
            chart4Datasets.push({ label:'Meta Ads (Combined) Deal Size ($)', data: dsAgg, tension:.3, borderColor: base, backgroundColor: base+'33' });
            campaignsForDisplay.forEach((cn, idx) => {
              // Select a distinct base color for each campaign from the metaPalette
              const colorVar = metaPalette[idx % metaPalette.length];
              chart4Datasets.push({ label:'Meta Ads - '+cn+' Deal Size ($)', data: seriesFor(months, 'Meta Ads', 'dealSize', [cn]), tension:.3, borderColor: colorVar, backgroundColor: colorVar+'33' });
            });
          } else {
            // No specific campaigns selected: aggregated across all campaigns
            const dsAll = seriesFor(months, 'Meta Ads', 'dealSize', selectedCampaigns);
            chart4Datasets.push({ label:'Meta Ads Deal Size ($)', data: dsAll, tension:.3, borderColor: base, backgroundColor: base+'33' });
          }
        } else {
          const base = colorMap[ch] || colorMap['all'];
          chart4Datasets.push({ label: ch + ' Deal Size ($)', data: seriesFor(months, ch, 'dealSize', selectedCampaigns), tension:.3, borderColor: base, backgroundColor: base+'33' });
        }
      });
    }
    // Append difference dataset for deal size across all channels
    {
      const dsSeries1 = getSeriesForDisplayRange('all', 'dealSize', months1, selectedCampaigns);
      const dsSeries2 = getSeriesForDisplayRange('all', 'dealSize', months2, selectedCampaigns);
      const diffDs = dsSeries1.map((v,i) => { const a = v||0; const b = dsSeries2[i]||0; return a - b; });
      chart4Datasets.push({ label:'Deal Size Diff (R1-R2)', data: diffDs, tension:.3, borderColor: diffColor, backgroundColor: diffColor+'33', borderDash:[3,3] });
    }
    ch4 = new Chart(document.getElementById('trend4'), { type:'line', data:{labels, datasets:chart4Datasets}, options:{responsive:true, scales:{y:{beginAtZero:true}}} });

    // Additional metrics computation
    // Helper function to get aggregated metrics for a channel and month
    function getMetricsFor(channel, month, selectedCampaigns){
      let leads=0, sv=0, won=0, spendVal=0, dealSize=0;
      if(channel==='all'){
        // Aggregate across all channels, applying campaign filter for Meta Ads
        channels.forEach(chinner => {
          let data;
          if(chinner === 'Meta Ads'){
            // If specific campaigns selected (not "all") accumulate across them
            if(Array.isArray(selectedCampaigns) && selectedCampaigns.length > 0 && !selectedCampaigns.includes('all')){
              const combined = {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
              selectedCampaigns.forEach(cn => {
                const d = metaCampaign[month]?.[cn] || {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
                combined.leads += d.leads;
                combined.sv += d.sv;
                combined.won += d.won;
                combined.spend += d.spend;
                combined.dealSize += d.dealSize;
              });
              data = combined;
            } else {
              // Sum across all campaigns for the month
              const combined = {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
              const campaignsObj = metaCampaign[month] || {};
              Object.values(campaignsObj).forEach(d => {
                combined.leads += d.leads || 0;
                combined.sv += d.sv || 0;
                combined.won += d.won || 0;
                combined.spend += d.spend || 0;
                combined.dealSize += d.dealSize || 0;
              });
              data = combined;
            }
          } else {
            data = datasets[month]?.[chinner] || {leads:0, sv:0, won:0, spend:0, dealSize:0};
          }
          leads += data.leads;
          sv += data.sv;
          won += data.won;
          spendVal += data.spend;
          dealSize += data.dealSize;
        });
      } else {
        if(channel === 'Meta Ads'){
          let data;
          if(Array.isArray(selectedCampaigns) && selectedCampaigns.length > 0 && !selectedCampaigns.includes('all')){
            const combined = {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
            selectedCampaigns.forEach(cn => {
              const d = metaCampaign[month]?.[cn] || {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
              combined.leads += d.leads;
              combined.sv += d.sv;
              combined.won += d.won;
              combined.spend += d.spend;
              combined.dealSize += d.dealSize;
            });
            data = combined;
          } else {
            // If "all" or no selection, sum across all campaigns for the month
            const combined = {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
            const campaignsObj = metaCampaign[month] || {};
            Object.values(campaignsObj).forEach(d => {
              combined.leads += d.leads || 0;
              combined.sv += d.sv || 0;
              combined.won += d.won || 0;
              combined.spend += d.spend || 0;
              combined.dealSize += d.dealSize || 0;
            });
            data = combined;
          }
          leads = data.leads;
          sv = data.sv;
          won = data.won;
          spendVal = data.spend;
          dealSize = data.dealSize;
        } else {
          const data = datasets[month]?.[channel] || {leads:0, sv:0, won:0, spend:0, dealSize:0};
          leads = data.leads; sv = data.sv; won = data.won; spendVal = data.spend; dealSize = data.dealSize;
        }
      }
      return {leads, sv, won, spend: spendVal, dealSize};
    }

    // Chart5: Cost per Site Visit and Cost per Deal Won
    const chart5Datasets=[];
    if(useAggregated){
      (useAggregated ? ['all'] : channels).forEach(ch => {
        const base = colorMap[ch] || colorMap['all'];
        const costSV = [];
        const costDeal = [];
        months.forEach(m => {
          const {leads, sv, won, spend, dealSize} = getMetricsFor(ch, m, selectedCampaigns);
          costSV.push(sv ? spend / sv : 0);
          costDeal.push(won ? spend / won : 0);
        });
        chart5Datasets.push({ label: (useAggregated?'All Channels':'') + (useAggregated?'':' '+ch) + ' Cost per Site Visit', data: costSV, tension:.3, borderColor: base, backgroundColor: base+'33' });
        chart5Datasets.push({ label: (useAggregated?'All Channels':'') + (useAggregated?'':' '+ch) + ' Cost per Deal Won', data: costDeal, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
      });
    } else {
      // Local helper to get metrics for a specific Meta campaign
      const getMetricsForCampaign = (month, campaignName) => {
        const d = (metaCampaign[month] && metaCampaign[month][campaignName]) || {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
        return {leads:d.leads || 0, sv:d.sv || 0, won:d.won || 0, spend:d.spend || 0, dealSize:d.dealSize || 0};
      };
      channels.forEach(ch => {
        if(ch === 'Meta Ads'){
          const campaignsForDisplay = Array.isArray(selectedCampaigns) ? selectedCampaigns.filter(c => c !== 'all') : [];
          const base = colorMap['Meta Ads'] || colorMap['all'];
          if(campaignsForDisplay.length > 0){
            // Combined cost metrics across selected campaigns
            const costSVAgg = [];
            const costDealAgg = [];
            months.forEach(m => {
              const {leads, sv, won, spend} = getMetricsFor('Meta Ads', m, selectedCampaigns);
              costSVAgg.push(sv ? spend / sv : 0);
              costDealAgg.push(won ? spend / won : 0);
            });
            chart5Datasets.push({ label:'Meta Ads (Combined) Cost per Site Visit', data: costSVAgg, tension:.3, borderColor: base, backgroundColor: base+'33' });
            chart5Datasets.push({ label:'Meta Ads (Combined) Cost per Deal Won', data: costDealAgg, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
            // Individual campaigns
            campaignsForDisplay.forEach((cn, idx) => {
              // Select a distinct base color for each campaign from the metaPalette
              const colorVar = metaPalette[idx % metaPalette.length];
              const costSV = [];
              const costDeal = [];
              months.forEach(m => {
                const {sv, won, spend} = getMetricsForCampaign(m, cn);
                costSV.push(sv ? spend / sv : 0);
                costDeal.push(won ? spend / won : 0);
              });
              chart5Datasets.push({ label:'Meta Ads - '+cn+' Cost per Site Visit', data: costSV, tension:.3, borderColor: colorVar, backgroundColor: colorVar+'33' });
              chart5Datasets.push({ label:'Meta Ads - '+cn+' Cost per Deal Won', data: costDeal, tension:.3, borderColor: lightenColor(colorVar, 30), backgroundColor: lightenColor(colorVar, 30)+'33', borderDash:[6,4] });
            });
          } else {
            // No specific campaigns selected: aggregated across all campaigns
            const costSV = [];
            const costDeal = [];
            months.forEach(m => {
              const {sv, won, spend} = getMetricsFor('Meta Ads', m, selectedCampaigns);
              costSV.push(sv ? spend / sv : 0);
              costDeal.push(won ? spend / won : 0);
            });
            chart5Datasets.push({ label:'Meta Ads Cost per Site Visit', data: costSV, tension:.3, borderColor: base, backgroundColor: base+'33' });
            chart5Datasets.push({ label:'Meta Ads Cost per Deal Won', data: costDeal, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
          }
        } else {
          const base = colorMap[ch] || colorMap['all'];
          const costSV = [];
          const costDeal = [];
          months.forEach(m => {
            const {sv, won, spend} = getMetricsFor(ch, m, selectedCampaigns);
            costSV.push(sv ? spend / sv : 0);
            costDeal.push(won ? spend / won : 0);
          });
          chart5Datasets.push({ label: ch + ' Cost per Site Visit', data: costSV, tension:.3, borderColor: base, backgroundColor: base+'33' });
          chart5Datasets.push({ label: ch + ' Cost per Deal Won', data: costDeal, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
        }
      });
    }
    // Append difference datasets for cost per site visit and cost per deal won across all channels
    {
      const spend1 = getSeriesForDisplayRange('all', 'spend', months1, selectedCampaigns);
      const spend2 = getSeriesForDisplayRange('all', 'spend', months2, selectedCampaigns);
      const sv1 = getSeriesForDisplayRange('all', 'sv', months1, selectedCampaigns);
      const sv2 = getSeriesForDisplayRange('all', 'sv', months2, selectedCampaigns);
      const won1 = getSeriesForDisplayRange('all', 'won', months1, selectedCampaigns);
      const won2 = getSeriesForDisplayRange('all', 'won', months2, selectedCampaigns);
      const costSV1 = spend1.map((s,i) => { const v = sv1[i]; return v ? s/v : 0; });
      const costSV2 = spend2.map((s,i) => { const v = sv2[i]; return v ? s/v : 0; });
      const costDeal1 = spend1.map((s,i) => { const w = won1[i]; return w ? s/w : 0; });
      const costDeal2 = spend2.map((s,i) => { const w = won2[i]; return w ? s/w : 0; });
      const diffCostSV = costSV1.map((v,i) => { const b = costSV2[i] || 0; return v - b; });
      const diffCostDeal = costDeal1.map((v,i) => { const b = costDeal2[i] || 0; return v - b; });
      chart5Datasets.push({ label:'Cost/SV Diff (R1-R2)', data: diffCostSV, tension:.3, borderColor: diffColor, backgroundColor: diffColor+'33', borderDash:[3,3] });
      chart5Datasets.push({ label:'Cost/Deal Diff (R1-R2)', data: diffCostDeal, tension:.3, borderColor: lightenColor(diffColor, 30), backgroundColor: lightenColor(diffColor, 30)+'33', borderDash:[3,3] });
    }
    ch5 = new Chart(document.getElementById('trend5'), { type:'line', data:{labels, datasets:chart5Datasets}, options:{responsive:true, scales:{y:{beginAtZero:true}}} });

    // Chart6: Average Deal Value and Marketing Profit
    const chart6Datasets=[];
    if(useAggregated){
      (useAggregated ? ['all'] : channels).forEach(ch => {
        const base = colorMap[ch] || colorMap['all'];
        const avgDeal=[];
        const profitArr=[];
        months.forEach(m => {
          const {leads, sv, won, spend, dealSize} = getMetricsFor(ch, m, selectedCampaigns);
          const avg = leads ? dealSize / leads : 0;
          const cpd = won ? spend / won : 0;
          profitArr.push(avg - cpd);
          avgDeal.push(avg);
        });
        chart6Datasets.push({ label: (useAggregated?'All Channels':'') + (useAggregated?'':' '+ch) + ' Avg Deal Value', data: avgDeal, tension:.3, borderColor: base, backgroundColor: base+'33' });
        chart6Datasets.push({ label: (useAggregated?'All Channels':'') + (useAggregated?'':' '+ch) + ' Marketing Profit', data: profitArr, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
      });
    } else {
      const getMetricsForCampaign = (month, campaignName) => {
        const d = (metaCampaign[month] && metaCampaign[month][campaignName]) || {leads:0, sv:0, closed:0, won:0, spend:0, dealSize:0};
        return {leads:d.leads || 0, sv:d.sv || 0, won:d.won || 0, spend:d.spend || 0, dealSize:d.dealSize || 0};
      };
      channels.forEach(ch => {
        if(ch === 'Meta Ads'){
          const campaignsForDisplay = Array.isArray(selectedCampaigns) ? selectedCampaigns.filter(c => c !== 'all') : [];
          const base = colorMap['Meta Ads'] || colorMap['all'];
          if(campaignsForDisplay.length > 0){
            // Combined metrics across selected campaigns
            const avgCombined=[];
            const profitCombined=[];
            months.forEach(m => {
              const {leads, won, spend, dealSize} = getMetricsFor('Meta Ads', m, selectedCampaigns);
              const avg = leads ? dealSize / leads : 0;
              const cpd = won ? spend / won : 0;
              profitCombined.push(avg - cpd);
              avgCombined.push(avg);
            });
            chart6Datasets.push({ label:'Meta Ads (Combined) Avg Deal Value', data: avgCombined, tension:.3, borderColor: base, backgroundColor: base+'33' });
            chart6Datasets.push({ label:'Meta Ads (Combined) Marketing Profit', data: profitCombined, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
            // Individual campaigns
            campaignsForDisplay.forEach((cn, idx) => {
              // Select a distinct base color for each campaign from the metaPalette
              const colorVar = metaPalette[idx % metaPalette.length];
              const avgVals=[];
              const profitVals=[];
              months.forEach(m => {
                const {leads, won, spend, dealSize} = getMetricsForCampaign(m, cn);
                const avg = leads ? dealSize / leads : 0;
                const cpd = won ? spend / won : 0;
                profitVals.push(avg - cpd);
                avgVals.push(avg);
              });
              chart6Datasets.push({ label:'Meta Ads - '+cn+' Avg Deal Value', data: avgVals, tension:.3, borderColor: colorVar, backgroundColor: colorVar+'33' });
              chart6Datasets.push({ label:'Meta Ads - '+cn+' Marketing Profit', data: profitVals, tension:.3, borderColor: lightenColor(colorVar, 30), backgroundColor: lightenColor(colorVar, 30)+'33', borderDash:[6,4] });
            });
          } else {
            // No specific campaigns selected: aggregated across all campaigns
            const avgVals=[];
            const profitVals=[];
            months.forEach(m => {
              const {leads, won, spend, dealSize} = getMetricsFor('Meta Ads', m, selectedCampaigns);
              const avg = leads ? dealSize / leads : 0;
              const cpd = won ? spend / won : 0;
              profitVals.push(avg - cpd);
              avgVals.push(avg);
            });
            chart6Datasets.push({ label:'Meta Ads Avg Deal Value', data: avgVals, tension:.3, borderColor: base, backgroundColor: base+'33' });
            chart6Datasets.push({ label:'Meta Ads Marketing Profit', data: profitVals, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
          }
        } else {
          const base = colorMap[ch] || colorMap['all'];
          const avgVals=[];
          const profitVals=[];
          months.forEach(m => {
            const {leads, won, spend, dealSize} = getMetricsFor(ch, m, selectedCampaigns);
            const avg = leads ? dealSize / leads : 0;
            const cpd = won ? spend / won : 0;
            profitVals.push(avg - cpd);
            avgVals.push(avg);
          });
          chart6Datasets.push({ label: ch + ' Avg Deal Value', data: avgVals, tension:.3, borderColor: base, backgroundColor: base+'33' });
          chart6Datasets.push({ label: ch + ' Marketing Profit', data: profitVals, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
        }
      });
    }
    // Append difference datasets for average deal value and marketing profit across all channels
    {
      const spend1 = getSeriesForDisplayRange('all', 'spend', months1, selectedCampaigns);
      const spend2 = getSeriesForDisplayRange('all', 'spend', months2, selectedCampaigns);
      const leads1 = getSeriesForDisplayRange('all', 'leads', months1, selectedCampaigns);
      const leads2 = getSeriesForDisplayRange('all', 'leads', months2, selectedCampaigns);
      const won1 = getSeriesForDisplayRange('all', 'won', months1, selectedCampaigns);
      const won2 = getSeriesForDisplayRange('all', 'won', months2, selectedCampaigns);
      const dealSize1 = getSeriesForDisplayRange('all', 'dealSize', months1, selectedCampaigns);
      const dealSize2 = getSeriesForDisplayRange('all', 'dealSize', months2, selectedCampaigns);
      const avg1 = dealSize1.map((d,i) => { const l = leads1[i]; return l ? d / l : 0; });
      const avg2 = dealSize2.map((d,i) => { const l = leads2[i]; return l ? d / l : 0; });
      const cpd1 = spend1.map((s,i) => { const w = won1[i]; return w ? s / w : 0; });
      const cpd2 = spend2.map((s,i) => { const w = won2[i]; return w ? s / w : 0; });
      const profit1 = avg1.map((a,i) => a - cpd1[i]);
      const profit2 = avg2.map((a,i) => a - cpd2[i]);
      const diffAvg = avg1.map((v,i) => { const b = avg2[i] || 0; return v - b; });
      const diffProfit = profit1.map((v,i) => { const b = profit2[i] || 0; return v - b; });
      chart6Datasets.push({ label:'Avg Deal Value Diff (R1-R2)', data: diffAvg, tension:.3, borderColor: diffColor, backgroundColor: diffColor+'33', borderDash:[3,3] });
      chart6Datasets.push({ label:'Marketing Profit Diff (R1-R2)', data: diffProfit, tension:.3, borderColor: lightenColor(diffColor, 30), backgroundColor: lightenColor(diffColor, 30)+'33', borderDash:[3,3] });
    }
    ch6 = new Chart(document.getElementById('trend6'), { type:'line', data:{labels, datasets:chart6Datasets}, options:{responsive:true, scales:{y:{beginAtZero:true}}} });

    // Chart7: Leads Conversion (Leads to Site Visit %) and Deal Conversion (Leads to Deal Won %)
    const chart7Datasets=[];
    if(useAggregated){
      // Aggregated view across all selected channels. For Meta Ads, the selected campaigns (if any) are respected via getMetricsFor.
      (useAggregated ? ['all'] : channels).forEach(ch => {
        const base = colorMap[ch] || colorMap['all'];
        const leadsConv=[];
        const dealConv=[];
        months.forEach(m => {
          const {leads, sv, won} = getMetricsFor(ch, m, selectedCampaigns);
          leadsConv.push(leads ? (sv / leads) * 100 : 0);
          dealConv.push(leads ? (won / leads) * 100 : 0);
        });
        chart7Datasets.push({ label: (useAggregated?'All Channels':'') + (useAggregated?'':' '+ch) + ' Leads‚ÜíSV %', data: leadsConv, tension:.3, borderColor: base, backgroundColor: base+'33' });
        chart7Datasets.push({ label: (useAggregated?'All Channels':'') + (useAggregated?'':' '+ch) + ' Leads‚ÜíWon %', data: dealConv, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
      });
    } else {
      // Non-aggregated view: show each channel separately, with detailed breakdown for Meta Ads campaigns
      channels.forEach(ch => {
        if(ch === 'Meta Ads'){
          const campaignsForDisplay = Array.isArray(selectedCampaigns) ? selectedCampaigns.filter(c => c !== 'all') : [];
          const base = colorMap['Meta Ads'] || colorMap['all'];
          if(campaignsForDisplay.length > 0){
            // Combined conversion metrics across selected campaigns
            const leadsConvAgg = [];
            const dealConvAgg = [];
            months.forEach(m => {
              const {leads, sv, won} = getMetricsFor('Meta Ads', m, selectedCampaigns);
              leadsConvAgg.push(leads ? (sv / leads) * 100 : 0);
              dealConvAgg.push(leads ? (won / leads) * 100 : 0);
            });
            chart7Datasets.push({ label:'Meta Ads (Combined) Leads‚ÜíSV %', data: leadsConvAgg, tension:.3, borderColor: base, backgroundColor: base+'33' });
            chart7Datasets.push({ label:'Meta Ads (Combined) Leads‚ÜíWon %', data: dealConvAgg, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
            // Individual campaign conversion metrics
            campaignsForDisplay.forEach((cn, idx) => {
              // Select a distinct base color for each campaign from the metaPalette
              const colorVar = metaPalette[idx % metaPalette.length];
              const leadsConvC = [];
              const dealConvC = [];
              months.forEach(m => {
                const d = (metaCampaign[m] && metaCampaign[m][cn]) || {leads:0, sv:0, won:0, spend:0, dealSize:0};
                const leadsVal = d.leads || 0;
                const svVal = d.sv || 0;
                const wonVal = d.won || 0;
                leadsConvC.push(leadsVal ? (svVal / leadsVal) * 100 : 0);
                dealConvC.push(leadsVal ? (wonVal / leadsVal) * 100 : 0);
              });
              chart7Datasets.push({ label:'Meta Ads - '+cn+' Leads‚ÜíSV %', data: leadsConvC, tension:.3, borderColor: colorVar, backgroundColor: colorVar+'33' });
              chart7Datasets.push({ label:'Meta Ads - '+cn+' Leads‚ÜíWon %', data: dealConvC, tension:.3, borderColor: lightenColor(colorVar, 30), backgroundColor: lightenColor(colorVar, 30)+'33', borderDash:[6,4] });
            });
          } else {
            // No specific campaigns selected: aggregated across all campaigns
            const leadsConvAll = [];
            const dealConvAll = [];
            months.forEach(m => {
              const {leads, sv, won} = getMetricsFor('Meta Ads', m, selectedCampaigns);
              leadsConvAll.push(leads ? (sv / leads) * 100 : 0);
              dealConvAll.push(leads ? (won / leads) * 100 : 0);
            });
            chart7Datasets.push({ label:'Meta Ads Leads‚ÜíSV %', data: leadsConvAll, tension:.3, borderColor: base, backgroundColor: base+'33' });
            chart7Datasets.push({ label:'Meta Ads Leads‚ÜíWon %', data: dealConvAll, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
          }
        } else {
          // Non-Meta channel: compute conversion metrics using getMetricsFor
          const base = colorMap[ch] || colorMap['all'];
          const leadsConv=[];
          const dealConv=[];
          months.forEach(m => {
            const {leads, sv, won} = getMetricsFor(ch, m, selectedCampaigns);
            leadsConv.push(leads ? (sv / leads) * 100 : 0);
            dealConv.push(leads ? (won / leads) * 100 : 0);
          });
          chart7Datasets.push({ label: ch + ' Leads‚ÜíSV %', data: leadsConv, tension:.3, borderColor: base, backgroundColor: base+'33' });
          chart7Datasets.push({ label: ch + ' Leads‚ÜíWon %', data: dealConv, tension:.3, borderColor: lightenColor(base, 30), backgroundColor: lightenColor(base, 30)+'33', borderDash:[6,4] });
        }
      });
    }
    // Append difference datasets for conversion metrics (Leads‚ÜíSV % and Leads‚ÜíWon %) across all channels
    {
      const leads1Arr = getSeriesForDisplayRange('all', 'leads', months1, selectedCampaigns);
      const leads2Arr = getSeriesForDisplayRange('all', 'leads', months2, selectedCampaigns);
      const sv1Arr = getSeriesForDisplayRange('all', 'sv', months1, selectedCampaigns);
      const sv2Arr = getSeriesForDisplayRange('all', 'sv', months2, selectedCampaigns);
      const won1Arr = getSeriesForDisplayRange('all', 'won', months1, selectedCampaigns);
      const won2Arr = getSeriesForDisplayRange('all', 'won', months2, selectedCampaigns);
      const convSV1 = leads1Arr.map((l,i) => { const sv = sv1Arr[i]; return l ? (sv / l) * 100 : 0; });
      const convSV2 = leads2Arr.map((l,i) => { const sv = sv2Arr[i]; return l ? (sv / l) * 100 : 0; });
      const convWon1 = leads1Arr.map((l,i) => { const w = won1Arr[i]; return l ? (w / l) * 100 : 0; });
      const convWon2 = leads2Arr.map((l,i) => { const w = won2Arr[i]; return l ? (w / l) * 100 : 0; });
      const diffConvSV = convSV1.map((v,i) => { const b = convSV2[i] || 0; return v - b; });
      const diffConvWon = convWon1.map((v,i) => { const b = convWon2[i] || 0; return v - b; });
      chart7Datasets.push({ label:'Leads‚ÜíSV Diff (R1-R2)', data: diffConvSV, tension:.3, borderColor: diffColor, backgroundColor: diffColor+'33', borderDash:[3,3] });
      chart7Datasets.push({ label:'Leads‚ÜíWon Diff (R1-R2)', data: diffConvWon, tension:.3, borderColor: lightenColor(diffColor, 30), backgroundColor: lightenColor(diffColor, 30)+'33', borderDash:[3,3] });
    }
    ch7 = new Chart(document.getElementById('trend7'), { type:'line', data:{labels, datasets:chart7Datasets}, options:{responsive:true, scales:{y:{beginAtZero:true}}} });
  }

  document.getElementById('channelCheckboxes').addEventListener('change', ()=>{ fillCampaignOptions(); render(); });
  // Campaign checkboxes trigger render via their own event listeners; no need to attach an additional listener here.

});
</script>
</body>
</html>
